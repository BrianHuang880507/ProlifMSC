import os
import cv2
import numpy as np
import torch
from tqdm import tqdm
from prolifmsc.utils.io import get_paths, extract_identifier, get_model
from cellpose import models, io, plot, utils
from torchvision.ops import masks_to_boxes

import warnings

warnings.filterwarnings("ignore", category=FutureWarning)


def outlines_to_text(base, outlines):
    """Save outlines as text in a file.

    Args:
        base (str): Base file name for the output text file.
        outlines (list): List of outlines as pixel coordinates.

    Returns:
        None
    """
    with open(base + "_cp_outlines.txt", "w") as f:
        for o in outlines:
            xy = list(o.flatten())
            xy_str = ",".join(map(str, xy))
            f.write(xy_str)
            f.write("\n")


def get_cyto_masks(img_path, model_name):
    """Generate segmentation masks using the Cellpose model.

    Args:
        img_path (str): Path to the input image.

    Returns:
        ndarray: Segmentation masks generated by the Cellpose model.
    """
    model_path = get_model(model_name)
    model = models.CellposeModel(gpu=True, model_type=model_path)
    img = io.imread(img_path)
    masks, flow, _ = model.eval(img, channels=[0, 0])
    base_name = os.path.splitext(os.path.basename(img_path))[0]
    save_path = os.path.join("data", "output", "segmentation", base_name + "_cyto")
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    save_segmentation(img_path, masks, save_path, channels=[0, 0])
    return masks


def get_nuclei_masks(img_path, model_name):
    """Generate segmentation masks using the Cellpose model.

    Args:
        img_path (str): Path to the input image.

    Returns:
        ndarray: Segmentation masks generated by the Cellpose model.
    """
    model_path = get_model(model_name)
    model = models.CellposeModel(gpu=True, model_type=model_path)
    img = io.imread(img_path)
    masks, flow, _ = model.eval(img, channels=[0, 0])
    base_name = os.path.splitext(os.path.basename(img_path))[0]
    save_path = os.path.join("data", "output", "segmentation", base_name + "_nuclei")
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    save_segmentation(img_path, masks, save_path, channels=[0, 0])
    return masks


def get_outlines(masks):
    """Get outlines of masks as a list to loop over for plotting.

    Args:
        masks (ndarray): masks (0=no cells, 1=first cell, 2=second cell,...)

    Returns:
        list: List of outlines as pixel coordinates.

    """
    outpix = []
    for n in np.unique(masks)[1:]:
        mn = masks == n
        if mn.sum() > 0:
            contours = cv2.findContours(
                mn.astype(np.uint8),
                mode=cv2.RETR_EXTERNAL,
                method=cv2.CHAIN_APPROX_NONE,
            )
            contours = contours[-2]
            cmax = np.argmax([c.shape[0] for c in contours])
            pix = contours[cmax].astype(int).squeeze()
            if len(pix) > 4:
                outpix.append(pix)
            else:
                outpix.append(np.zeros((0, 2)))
    return outpix


def mask_overlay(img, masks, colors=None):
    """Overlay masks on image without converting it to grayscale.

    Args:
        img (int or float, 3D array): Image of size [Ly x Lx x 3].
        masks (int, 2D array): Masks where 0=NO masks; 1,2,...=mask labels.
        colors (int, 2D array, optional): Size [nmasks x 3], each entry is a color in 0-255 range.

    Returns:
        RGB (uint8, 3D array): Array of masks overlaid on original image.
    """
    if img.ndim != 3 or img.shape[-1] != 3:
        raise ValueError("Input image must be a 3D array with 3 color channels (RGB).")

    # Normalize the input image if needed
    img = img.astype(np.float32)
    if img.max() > 1:
        img /= 255.0

    # Prepare HSV for masks
    HSV = np.zeros((img.shape[0], img.shape[1], 3), np.float32)
    HSV[:, :, 2] = 1.0  # Value channel set to maximum brightness
    hues = np.linspace(0, 1, masks.max() + 1)[np.random.permutation(masks.max())]

    # If custom colors are provided, normalize to HSV space
    if colors is not None:
        if colors.max() > 1:
            colors = np.float32(colors) / 255
        colors = utils.rgb_to_hsv(colors)

    # Overlay each mask
    for n in range(1, masks.max() + 1):
        ipix = (masks == n).nonzero()
        if colors is None:
            HSV[ipix[0], ipix[1], 0] = hues[n - 1]  # Assign hue
        else:
            HSV[ipix[0], ipix[1], 0] = colors[n - 1, 0]
        HSV[ipix[0], ipix[1], 1] = 1.0  # Saturation to max for mask regions

    # Convert HSV back to RGB and blend with original image
    overlay = (utils.hsv_to_rgb(HSV) * 255).astype(np.uint8)
    RGB = (overlay * 0.5 + img * 255 * 0.5).astype(
        np.uint8
    )  # Blend the original and mask overlay

    return RGB


def save_segmentation(img_path, maski, save_path, channels):
    img = io.imread(img_path)
    img0 = img.copy()
    if img0.shape[-1] < 3 or img0.ndim < 3:
        img0 = plot.image_to_rgb(img0, channels=channels)
    overlay = mask_overlay(img0, maski)
    io.imsave(save_path + "_overlay.jpg", overlay)


def process_images_and_crop(pc_folder_name, df_folder_name):
    """Process images to segment and crop regions based on masks.

    Args:
        pc_folder_name (str): Path to the folder containing PC images.
        df_folder_name (str): Path to the folder containing DF images.

    Returns:
        None
    """
    pc_images = get_paths(pc_folder_name, crop=True)
    df_images = get_paths(df_folder_name, crop=True)

    for pc_img_path in tqdm(pc_images, desc="影像處理中..."):
        pc_base_name = os.path.basename(pc_img_path)
        pc_identifier = extract_identifier(pc_base_name)

        df_img_path = next(
            (
                img
                for img in df_images
                if extract_identifier(os.path.basename(img)) == pc_identifier
            ),
            None,
        )

        if df_img_path:
            df_img = cv2.imread(df_img_path)

            cyto_masks = get_cyto_masks(pc_img_path, model_name="model_BDL6_label_test")

            nuclei_masks = get_nuclei_masks(
                pc_img_path, model_name="model_BDL3_label_dapi"
            )

            unique_cyto_labels = np.unique(cyto_masks)[1:]
            binary_cyto_masks = np.array(
                [(cyto_masks == label).astype(np.uint8) for label in unique_cyto_labels]
            )

            masks_tensor = torch.tensor(binary_cyto_masks, dtype=torch.float32)

            bounding_boxes = masks_to_boxes(masks_tensor)

            masked_img = df_img.copy()

            base_name = os.path.splitext(os.path.basename(df_img_path))[0]

            df_crop_folder = os.path.join("data", "output", "crop", df_folder_name)
            os.makedirs(df_crop_folder, exist_ok=True)
            df_outline_folder = os.path.join(
                "data", "output", "outlines", df_folder_name
            )
            os.makedirs(df_outline_folder, exist_ok=True)

            for i, box in enumerate(
                tqdm(bounding_boxes, desc=f"分割細胞中 {pc_base_name}")
            ):
                x_min, y_min, x_max, y_max = map(int, box)

                current_mask = binary_cyto_masks[i]
                masked_img_copy = masked_img.copy()
                masked_img_copy[current_mask == 0] = 0
                cropped_img = masked_img_copy[y_min:y_max, x_min:x_max]

                output_img_path = os.path.join(df_crop_folder, f"{base_name}_{i}.jpg")
                output_txt_path = os.path.join(df_outline_folder, f"{base_name}_{i}")

                outlines = get_outlines(current_mask)
                outlines_to_text(output_txt_path, outlines)
                cv2.imwrite(output_img_path, cropped_img)
        else:
            print(f"No matching image found for {pc_base_name}")
